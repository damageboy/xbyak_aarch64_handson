# Hands on: Try Arm SVE on Docker

## Summary

This is a hands-on document for people who don't have an actual machine to try Arm SVE on Docker.

To have an environment to try Arm SVE with QEMU, just run the following command.

```sh
docker run -it kaityo256/xbyak_aarch64_handson
```

Once the container process is up, you will see a screen like the one below.

```sh
$ docker run -it kaityo256/xbyak_aarch64_handson
[user@2cd82e1ea4e3 ~]$
```

This is an image of ArchLinux with the necessary software pre-installed. In the following, you will try ARM SVE with intrinsic functions and Xbyak_aarch64.

## Intrinsic Functiosn

You can use Arm SVE instructions via intrinsic function of C language, which is called the Arm C Language Extensions (ACLEs) for SVE. The sample codes for the intrinsic functions are in the directory `~/xbyak_aarch64_handson/sample/intrinsic`.

### 1. SVE Length

Since the length of the vector is *scalble*, and the length is not determined at compile time. So, let's first look at a sample that gets the vector length at runtime.

The sample code can be built as follows.

```sh
cd 01_sve_length/
make
```

Then you can run the executable using QEMU.

```sh
$ qemu-aarch64 ./a.out
SVE is available. The length is 512 bits
```

You can specify the vector length in the QEMU options.

```sh
$ qemu-aarch64 -cpu max,sve128=on ./a.out
SVE is available. The length is 128 bits

$ qemu-aarch64 -cpu max,sve256=on ./a.out
SVE is available. The length is 256 bits
```

Here is the source code (`sve_length.cpp`).

```sh
#include <cstdio>
#ifdef __ARM_FEATURE_SVE
#include <arm_sve.h>
#endif

int main() {
  int n = 0;
#ifdef __ARM_FEATURE_SVE
  n = svcntb() * 8;
#endif
  if (n) {
    printf("SVE is available. The length is %d bits\n", n);
  } else {
    printf("SVE is unavailable.\n");
  }
}
```

Whether or not ARM SVE can be used can be determined by whether or not __ARM_FEATURE_SVE is defined. If `__ARM_FEATURE_SVE` is defined, then you can use intrinsic functions for SVE by including `arm_sve.h`.

The vector length can be obtained by `svcntb()` which returns the vector length in bytes. The corresponding instruction is `cntb`. The name of a ACLE SVE function consists of a prefix `sv` followed by the corresponding instruction in lower case.

In order to enable SVE, you need to compile with the `-march=armv8-a+sve` option. Without the option, `__ARM_FEATURE_SVE` will not be defined.

```sh
$ aarch64-linux-gnu-g++ -static sve_length.cpp
$ qemu-aarch64 ./a.out
SVE is unavailable.
```

### 2. Predicate registers

Arm SVE adopts *Predicate-centric Approach*. Most of ACLE SVE functions involve predicate registers, which allow you to control whether or not to execute an instruction on an element-by-element basis. The predicate register has different lengths depending on the vector length, and the length is not determined at compile time. Here, we will try to visualize the predicate register.

The type corresponding to the predicate register is `svbool_t`.

The sample code can be built as follows.

```sh
cd 02_predicatemake
make
```

It is useful to prepare a function that takes a variable of type `svbool_t` and prints its bit representation.

```cpp
void show_pr(svbool_t tp) {
  int n = svcntb();
  std::vector<int8_t> a(n);
  std::vector<int8_t> b(n);
  std::fill(a.begin(), a.end(), 1);
  std::fill(b.begin(), b.end(), 0);
  svint8_t va = svld1_s8(tp, a.data());
  svst1_s8(tp, b.data(), va);
  for (int i = 0; i < n; i++) {
    std::cout << (int)b[n - i - 1];
  }
  std::cout << std::endl;
}
```

To set all bits of the predicate register, use `svptrue` function family. For example, to use a predicate register as a byte-by-byte mask, use `svptrue_b8`.

```cpp
show_pr(svptrue_b8());
```

The output will look like this.

```txt
1111111111111111111111111111111111111111111111111111111111111111
```

The function `svptrue_b8()` is equivalent to the function `svptrue_pat_b8` with `SV_ALL` option, and the corresponding assembly is `ptrue p0.b, ALL`.

Similarly, the output results for `svptrue_b16`, `svptrue_b32`, and `svptrue_b64` are as follows.

```txt
svptrue_b16
0101010101010101010101010101010101010101010101010101010101010101
svptrue_b32
0001000100010001000100010001000100010001000100010001000100010001
svptrue_b64
0000000100000001000000010000000100000001000000010000000100000001
```

The correspondence between `svptrue` function family and assembly is as follows.

* `svptrue_b8` => `ptrue p0.b, ALL`
* `svptrue_b16` => `ptrue p0.h, ALL`
* `svptrue_b32` => `ptrue p0.s, ALL`
* `svptrue_b64` => `ptrue p0.d, ALL`

### 3. Vector operations

### 4. Fizz Buzz Implementation with ACLE SVE

## Xbyak_aarch64

### 1. Test

### 2. Calling convention

### 3. Display the assembler mnemonics generated by Xbyak

### 4. Fizz Buzz Implementation with Xbyak

## Licence

MIT
